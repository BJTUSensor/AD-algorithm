import numpy as np

def anisodiff2D(img,kappa, num_iter, delta_t,option):
    '''
    ANISODIFF2D 经典PM模型的各向异性扩散
    该函数执行灰度图像上的各向异性扩散（经典PM模型），被认为是一个二维的网络结构的8个相邻节点的扩散传导
    参数描述：
            IMG         - 原始图像
            NUM_ITER    - 迭代次数
            DELTA_T     - 积分常数（0 <=  delta_t <= 1/7),通常情况下，由于数值稳定性，此参数设置为它的最大值
            KAPPA       - 控制传导的梯度模阈值，控制平滑,越大越平滑
            OPTION      - 传导系数函数选择（Perona & Malik 提出）：
                          1 - c(x,y,t) = exp(-(nablaI/Kappa)**2)
                          2 - c(x,y,t) = 1/(1 + (nalbaI/kappa)**2)
    '''

    #中心像素距离
    dx = 1
    dy = 1
    dd = np.sqrt(2)

    #二维卷积掩模-8个方向上的梯度差分
    hN = np.array([[0,1,0],[0,-1,0],[0,0,0]])
    hS = np.array([[0,0,0],[0,-1,0],[0,1,0]])
    hE = np.array([[0,0,0],[0,-1,1],[0,0,0]])
    hW = np.array([[0,0,0],[1,-1,0],[0,0,0]])
    hNE = np.array([[0,0,1],[0,-1,0],[0,0,0]])
    hSE = np.array([[0,0,0],[0,-1,0],[0,0,1]])
    hSW = np.array([[0,0,0],[0,-1,0],[1,0,0]])
    hNW = np.array([[1,0,0],[0,-1,0],[0,0,0]])
    #各向异性扩散
    rows = img.shape[0]
    cols = img.shape[1]

    diff_img=img
    for t in range(num_iter):
  
        #计算8个方向的梯度
        #nablaN = cv2.filter2D(diff_img, -1, kernel=hN)          #-1:目标图像与原图像深度保持一致
        #nablaS = cv2.filter2D(diff_img, -1, kernel=hS)
        #nablaW = cv2.filter2D(diff_img, -1, kernel=hW)
        #nablaE = cv2.filter2D(diff_img, -1, kernel=hE)
        #nablaNE = cv2.filter2D(diff_img, -1, kernel=hNE)
        #nablaSE = cv2.filter2D(diff_img, -1, kernel=hSE)
        #nablaSW = cv2.filter2D(diff_img, -1, kernel=hSW)
        #nablaNW = cv2.filter2D(diff_img, -1, kernel=hNW)

        diff1 = np.zeros((rows+2,cols+2))
        diff1[1:rows+1,1:cols+1]=diff_img
        nablaN = diff1[0:rows,1:cols+1] - diff_img
        nablaS = diff1[2:,1:cols+1] - diff_img
        nablaE = diff1[1:rows+1,2:] - diff_img
        nablaW = diff1[1:rows+1,0:cols] - diff_img
        nablaNE = diff1[0:rows,2:] - diff_img
        nablaSE = diff1[2:,2:] - diff_img
        nablaSW = diff1[2:,0:cols] - diff_img
        nablaNW = diff1[0:rows,0:cols] - diff_img

        #扩散函数
        if option==1:
            cN = np.exp(-(nablaN/kappa)**2)
            cS = np.exp(-(nablaS/kappa)**2)
            cW = np.exp(-(nablaW/kappa)**2)
            cE = np.exp(-(nablaE/kappa)**2)
            cNE = np.exp(-(nablaNE/kappa)**2)
            cSE = np.exp(-(nablaSE/kappa)**2)
            cSW = np.exp(-(nablaSW/kappa)**2)
            cNW = np.exp(-(nablaNW/kappa)**2)
        elif option == 2:
            cN = 1 / (1 + (nablaN / kappa)**2)
            cS = 1 / (1 + (nablaE / kappa)**2)
            cW = 1 / (1 + (nablaW / kappa)**2)
            cE = 1 / (1 + (nablaE / kappa)**2)
            cNE = 1 / (1 + (nablaNE / kappa)**2)
            cSE = 1 / (1 + (nablaSE / kappa)**2)
            cSW = 1 / (1 + (nablaSW / kappa)**2)
            cNW = 1 / (1 + (nablaNW / kappa)**2)

        #离散偏微分方程的解决方案
        delta = delta_t* (1/dy**2 * cN*nablaN +
                          1/dy**2 * cS*nablaS +
                          1/dx**2 * cW*nablaW +
                          1/dx**2 * cE*nablaE +
                          1/dd**2 * cNE*nablaNE +
                          1/dd**2 * cSE*nablaSE +
                          1/dd**2 * cSW*nablaSW +
                          1/dd**2 * cNW*nablaNW)

        diff_img = diff_img + delta

    return diff_img
